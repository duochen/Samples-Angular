const path = require('path');
const Server = require('../lib/server');
const EventEmitter = require('events').EventEmitter;
const tinylr = require('tiny-lr');

describe('Server', () => {
    let server;

    beforeEach(() => {
        server = new Server({
            dir: path.resolve(path.join(__dirname, 'assets'))
        });
    });

    afterEach(() => {
        server.stop();
    });

    it('should create defaults', () => {
        let settings = server.getDefaultSettings();
        expect(settings).toBeDefined();
    });

    it('should override defaults', () => {
        let custom = {
            host: '192.168.0.1',
            dir: '/tmp',
            spa: true,
            open: true,
            openUrl: '127.0.0.1',
            livereload: true,
            watch: [
                '/tmp/f1/**/*.js'
            ],
            verbose: true
        };

        server = new Server(custom);
        let config = server.config;

        expect(config.host).toBe(custom.host);
        expect(config.dir).toBe(custom.dir);
        expect(config.spa).toBe(custom.spa);
        expect(config.open).toBe(custom.open);
        expect(config.openUrl).toBe(custom.openUrl);
        expect(config.livereload).toBe(custom.livereload);
        expect(config.watch).toEqual(custom.watch);
        expect(config.verbose).toEqual(custom.verbose);
    });

    it('should use default settings', () => {
        server = new Server(null);
        expect(server.config).toEqual(server.getDefaultSettings());
    });

    it('should resolve root dir from config', () => {
        const config = {
            dir: './dist',
            silent: true
        };

        server = new Server(config);

        const expected = path.join(process.cwd(), 'dist');
        expect(server.config.dir).toBe(expected);
    });

    it('should log on watched file added', () => {
        let emitter = new EventEmitter();
        spyOn(server, 'log').and.stub();
        server.setupWatcher(emitter);
        emitter.emit('add');
        expect(server.log).toHaveBeenCalled();
    });

    it('should log on watched file changed', () => {
        let emitter = new EventEmitter();
        spyOn(server, 'log').and.stub();
        server.setupWatcher(emitter);
        emitter.emit('change');
        expect(server.log).toHaveBeenCalled();
    });

    it('should log on watched file unlinked', () => {
        let emitter = new EventEmitter();
        spyOn(server, 'log').and.stub();
        server.setupWatcher(emitter);
        emitter.emit('unlink');
        expect(server.log).toHaveBeenCalled();
    });

    it('should require config to log', () => {
        expect(server.log('message')).toBeFalsy();
    });

    it('should require verbose mode to log', () => {
        spyOn(console, 'log').and.stub();

        server.config.verbose = false;
        expect(server.log('message')).toBeFalsy();
        expect(console.log).not.toHaveBeenCalled();

        server.config.verbose = true;
        expect(server.log('message')).toBeTruthy();
        expect(console.log).toHaveBeenCalled();
    });

    it('should require message to log', () => {
        spyOn(console, 'log').and.stub();

        server.config.verbose = true;
        expect(server.log('message')).toBeTruthy();
        expect(server.log(null)).toBeFalsy();
        expect(console.log).toHaveBeenCalledTimes(1);
    });

    it('should raise live reload for path', () => {
        spyOn(tinylr, 'changed').and.stub();
        const watcher = new EventEmitter();
        server.setupWatcher(watcher);

        let path = 'some/path';
        watcher.emit('change', path);

        expect(tinylr.changed).toHaveBeenCalledWith(path);
    });

    it('should throttle live reload events', () => {
        spyOn(tinylr, 'changed').and.stub();
        const watcher = new EventEmitter();
        server.setupWatcher(watcher);

        const path = 'some/path';

        watcher.emit('change', path);
        watcher.emit('change', path);
        watcher.emit('change', path);

        expect(tinylr.changed).toHaveBeenCalledTimes(1);
        expect(tinylr.changed).toHaveBeenCalledWith(path);
    });

    it('should register custom index route for livereload', (done) => {
        server = new Server({
            livereload: true,
            dir: path.resolve(path.join(__dirname, 'assets')),
            silent: true
        });

        spyOn(server, 'serveLiveReloadedIndex').and.callThrough();

        server.start().then(() => {
            server.server.inject('/', (res) => {
                expect(res.statusCode).toBe(200);
                expect(server.serveLiveReloadedIndex).toHaveBeenCalled();
                done();
            });
        });
    });

    it('should serve live reload index file', (done) => {
        server = new Server({
            livereload: true,
            dir: path.resolve(path.join(__dirname, 'assets')),
            silent: true
        });

        spyOn(server, 'serveLiveReloadedIndex').and.callThrough();

        server.start().then(() => {
            server.server.inject('/index.html', (res) => {
                expect(res.statusCode).toBe(200);
                expect(server.serveLiveReloadedIndex).toHaveBeenCalled();
                done();
            });
        });
    });

    it('should open url on start', (done) => {
        server = new Server({
            port: 3001,
            open: true,
            silent: true
        });

        spyOn(server, 'openUrl').and.stub();
        server.start().then(() => {
            expect(server.openUrl).toHaveBeenCalledWith('http://localhost:3001');
            done();
        });
    });

    it('should log a message when opening url on start', (done) => {
        server = new Server({
            host: 'localhost',
            port: 3000,
            open: true
        });

        spyOn(server, 'openUrl').and.stub();
        spyOn(console, 'log').and.stub();

        server.start().then(() => {
            expect(server.openUrl).toHaveBeenCalled();
            expect(console.log).toHaveBeenCalledWith('Opening start page: http://localhost:3000');
            done();
        });
    });

    it('should open at custom url on start', (done) => {
        const targetUrl = 'http://localhost:3333';

        server = new Server({
            port: 3002,
            open: false,
            openUrl: targetUrl,
            silent: true
        });

        spyOn(server, 'openUrl').and.stub();
        server.start().then(() => {
            expect(server.openUrl).toHaveBeenCalledWith(targetUrl);
            done();
        });
    });

    it('should open custom url even if open switch enabled', (done) => {
        const targetUrl = 'http://localhost:3333';

        server = new Server({
            port: 3003,
            open: true,
            openUrl: targetUrl,
            silent: true
        });

        spyOn(server, 'openUrl').and.stub();
        server.start().then(() => {
            expect(server.openUrl).toHaveBeenCalledWith(targetUrl);
            done();
        });
    });

    it('should resolve promise on start', (done) => {
        server = new Server({
            port: 3002,
            silent: true
        });

        server.start().then(() => {
            done();
        });
    });

    it('should reject start on server register error', () => {
        spyOn(server.server, 'register').and.callFake((obj, err) => {
            err('Register error');
        });

        return expect(server.start()).rejects.toMatch('Register error');
    });

    it('should reject start on internal server error', () => {
        spyOn(server.server, 'start').and.callFake(err => {
            err('Start error');
        });

        return expect(server.start()).rejects.toMatch('Start error');
    });

    it('should log a message when setting up proxy in verbose mode', () => {
        spyOn(console, 'log').and.stub();

        server = new Server({
            proxy: {},
            verbose: true
        });

        expect(console.log).toHaveBeenCalledWith('Setting up proxy');
    });

    it('should not setup plugins when no data provided', () => {
        spyOn(server.server, 'register').and.stub();

        server.setupPlugins(null);
        server.setupPlugins([]);

        expect(server.server.register).not.toHaveBeenCalled();
    });

    it('should setup plugins', () => {
        spyOn(server.server, 'register').and.stub();

        server.setupPlugins([
            './plugins/plugin1.js',
            './plugins/plugin2.js'
        ]);

        expect(server.server.register).toHaveBeenCalled();
    });

    it('should setup plugins from config', (done) => {
        server = new Server({
            dir: path.resolve(path.join(__dirname, 'assets')),
            ext: [
                './plugins/plugin1.js'
            ]
        });

        server.start().then(() => {
            server.server.inject('/plugin1', (res) => {
                expect(res.statusCode).toBe(200);
                expect(res.payload).toBe('plugin 1 test passed');
                done();
            });
        });
    });

    it('should invoke custom header handler', (done) => {
        server = new Server({
            onResHeaders () {
                done();
            }
        });

        server.start().then(() => {
            server.server.inject('/', (res) => {
                expect(res.statusCode).toBe(200);
            });
        });
    });
});
